# Anime4K_Upscale_CNN_x2_VL.glsl Explained (Intuition First)

This guide explains `glsl/Upscale/Anime4K_Upscale_CNN_x2_VL.glsl` from first principles.
Goal: you can read the shader and understand what each pass is trying to achieve.

---

## 0) Tiny assumptions

Assume only:
- image = grid of pixels
- each pixel stores color numbers

Everything else explained from zero.

---

## 1) What this shader does

In one sentence:

It takes a low-res frame, computes learned detail clues, then rearranges those clues into a 2x bigger frame and adds them on top of the original color.

So the model predicts detail correction, not full color from scratch.

---

## 2) Mental model before code

Think "factory line":
- early stations: detect local clues (edges, line directions, flat areas)
- middle stations: refine and combine clues
- late stations: produce subpixel detail values
- final station: place those values into a 2x2 output pattern

If you keep this picture, the long code becomes readable.

---

## 3) What are pass, texture, channel?

### Pass
One mini-program run over every output pixel.
Input textures -> math -> one output texture.

### Texture
Image-sized grid of numbers.
Examples: `MAIN`, `conv2d_tf`, `conv2d_4_tf1`.

### Channel
One number slot inside a pixel.
`vec4` means 4 channels at one pixel.

Simple view: each pass writes another "helper image" with 4 numbers per pixel.

---

## 4) Why the file is huge

It is generated neural-network math:
- many learned constants
- repeated structure across layers
- loop-unrolled for speed

Do not read constant-by-constant first. Read structure first.

---

## 5) `//!...` lines are pipeline wiring

These are not regular GLSL statements.

Most important directives:
- `//!BIND X`: read texture `X`
- `//!SAVE Y`: write texture `Y`
- `//!WIDTH` / `//!HEIGHT`: output size of this pass
- `//!COMPONENTS 4`: output pixel has 4 numbers
- `//!WHEN ...`: run condition

Here, `//!WHEN` means this upscaler runs only when actual upscale ratio is large enough.

---

## 5.1) GLSL syntax used in this file (quick primer)

This section explains only syntax patterns you actually see in this shader.

### Function shape

You will repeatedly see:

```glsl
vec4 hook() {
    ...
    return result;
}
```

Meaning:
- `vec4` before function name = function returns 4 numbers
- `hook` = entry function name expected by this pipeline
- `return ...;` = final value written for this pixel in this pass

### Common types

- `float`: one decimal number
- `int`: one whole number
- `vec2`: 2-number vector (often x/y offset)
- `vec4`: 4-number vector (often channel pack)
- `ivec2`: 2-number integer vector (often pixel index)
- `mat4`: 4x4 matrix (channel mixer)

### Constructors

Examples:

```glsl
vec2(1.0, -1.0)
vec4(c0, c1, c2, c3)
ivec2(0, 1)
```

Meaning: create those types from listed values.

### Component access and indexing

You may access vector values by:
- named components: `.x`, `.y`, `.z`, `.w`
- numeric index: `[0]`, `[1]`, `[2]`, `[3]`

Both mean "pick one channel from vec4".

### Texture sampling helpers (provided by framework)

Examples used in this file:

```glsl
MAIN_tex(MAIN_pos)
MAIN_texOff(vec2(dx, dy))
```

Meaning:
- `*_tex(...)`: sample bound texture at coordinate
- `*_texOff(...)`: sample neighbor with offset from current pixel

These helpers are generated by the hosting shader framework.

### Macros (`#define`)

The file defines shorthand helpers like:

```glsl
#define go_0(x, y) max(conv2d_tf_texOff(vec2(x, y)), vec4(0.0))
```

Meaning:
- text substitution before compile
- used to avoid repeating long expressions

If macro line is long, GLSL uses `\` to continue to next line.

### Core math forms you see

- `a + b`, `a - b`, `a * b`: normal arithmetic
- `max(v, 0.0)`: clamp negative to zero (used for sign split)
- `mat4 * vec4`: linear mix from 4 input channels to 4 output channels

### Coordinate helpers in final pass

Used for depth-to-space placement:

```glsl
vec2 f = fract(pos * size);
ivec2 i = ivec2(f * 2.0);
```

Meaning:
- `fract(x)` keeps only fractional part
- convert to integer cell index to know which subpixel in 2x2 block

### Type conversion (cast)

When needed, file converts types explicitly:
- float -> int with `int(...)`
- float vector -> int vector with `ivec2(...)`

This avoids ambiguous math between float and integer domains.

---

## 6) Convolution from first principles

"Convolution" here means:
- read a small neighborhood
- multiply each sample by learned weight
- sum

For 3x3, neighborhood is:

```text
(-1,-1) (0,-1) (1,-1)
(-1, 0) (0, 0) (1, 0)
(-1, 1) (0, 1) (1, 1)
```

Intuition:
- different weight patterns detect different local structures
- one pattern may react to vertical edges
- another may react to diagonals

So each output channel is a "detector response map".

---

## 7) Why many passes help

One pass sees only immediate local pattern.
Many stacked passes can:
- combine early clues into richer clues
- indirectly use wider context

Intuition:
- pass 1: tiny fragments
- pass 4: stronger line continuity clues
- pass 10: mixed high-level confidence about where detail should go

---

## 8) Total pipeline in this file

There are 18 passes. Output names in order:

1. `conv2d_tf`
2. `conv2d_tf1`
3. `conv2d_1_tf`
4. `conv2d_1_tf1`
5. `conv2d_2_tf`
6. `conv2d_2_tf1`
7. `conv2d_3_tf`
8. `conv2d_3_tf1`
9. `conv2d_4_tf`
10. `conv2d_4_tf1`
11. `conv2d_5_tf`
12. `conv2d_5_tf1`
13. `conv2d_6_tf`
14. `conv2d_6_tf1`
15. `conv2d_last_tf`
16. `conv2d_last_tf1`
17. `conv2d_last_tf2`
18. final `MAIN`

Grouped view:
- passes 1-2: starter feature extractors (two branches)
- passes 3-14: repeated dual-branch 3x3 refinement
- passes 15-17: large 1x1 fusion heads
- pass 18: depth-to-space + residual add

---

## 9) Passes 1-2: two starter branches

Starts at:
- `glsl/Upscale/Anime4K_Upscale_CNN_x2_VL.glsl:24`
- `glsl/Upscale/Anime4K_Upscale_CNN_x2_VL.glsl:46`

Both read `MAIN` with 3x3 conv but with different weights.

Intuition:
- branch A and branch B are two different "first opinions"
- both look at same image, extract different clue styles

Outputs:
- A: `conv2d_tf`
- B: `conv2d_tf1`

---

## 10) Sign split: key concept for this file

From pass 3 onward, you see patterns like:

```glsl
max(x, 0.0)
max(-x, 0.0)
```

For value `x`:
- `p = max(x, 0)` positive part
- `n = max(-x, 0)` negative magnitude part

Useful identities:
- `x = p - n`
- `abs(x) = p + n`

Intuition:
- positive and negative evidence can mean different things
- splitting them lets later layers weight them separately

Example meaning (not exact labels):
- positive response: edge in one direction
- negative response: edge in opposite direction

---

## 11) Why this creates 16 logical inputs

In repeated blocks you often see `Conv-4x3x3x16`.

Interpretation:
- output channels: 4
- kernel size: 3x3
- logical input channels: 16

Where 16 comes from:
- two branch textures (`...tf` and `...tf1`) x 4 channels each = 8
- sign split doubles logical channels = 16

So 16 is channel count after split, not texture count.

---

## 12) Tiny numeric intuition for sign split

Suppose one feature value is `x = -0.7`.

Then:
- positive part = `max(-0.7,0) = 0`
- negative part = `max(0.7,0) = 0.7`

If next layer uses separate weights:
- positive weight = `+0.2`
- negative weight = `-1.1`

Contribution:
- `0.2 * 0 + (-1.1) * 0.7 = -0.77`

Without split, this independent control is harder.

---

## 13) Passes 3-14: repeated dual-branch refinement

Produced branch pairs:
- `(conv2d_1_tf, conv2d_1_tf1)`
- `(conv2d_2_tf, conv2d_2_tf1)`
- `(conv2d_3_tf, conv2d_3_tf1)`
- `(conv2d_4_tf, conv2d_4_tf1)`
- `(conv2d_5_tf, conv2d_5_tf1)`
- `(conv2d_6_tf, conv2d_6_tf1)`

Every block is still local 3x3 processing, but inputs are richer each step.

Intuition:
- branch A may carry one clue family
- branch B carries complementary clues
- repeated blocks sharpen, suppress noise, and combine cues

---

## 14) Passes 15-17: three 1x1 fusion heads

Starts around:
- `glsl/Upscale/Anime4K_Upscale_CNN_x2_VL.glsl:704`
- `glsl/Upscale/Anime4K_Upscale_CNN_x2_VL.glsl:785`
- `glsl/Upscale/Anime4K_Upscale_CNN_x2_VL.glsl:866`

Header: `Conv-4x1x1x112`.

Meaning:
- 1x1: no neighbor lookup
- operation is channel mixing at same pixel

Why 112 logical inputs:
- 14 bound textures (`conv2d_tf`, `conv2d_tf1`, ..., `conv2d_6_tf1`)
- each has 4 channels -> 56
- sign split doubles -> 112

Intuition:
- this is a big "mixer" stage
- it gathers almost all earlier clues and decides final packed detail features

Outputs:
- `conv2d_last_tf`
- `conv2d_last_tf1`
- `conv2d_last_tf2`

---

## 15) Final pass: depth-to-space (real x2 creation)

Starts at `glsl/Upscale/Anime4K_Upscale_CNN_x2_VL.glsl:947`.

This pass sets output size to 2x width and 2x height.

### Core idea
Earlier heads store subpixel details in channels.
Depth-to-space unpacks those channel values into different positions in a 2x2 output block.

Block intuition for one low-res source pixel:

```text
(0,0) (1,0)
(0,1) (1,1)
```

Shader computes which spot current output pixel is (`fract` -> `ivec2`), then selects proper channel value.

---

## 16) Why there are three last textures

Final assembly uses three heads:
- one contributes `c0`
- one contributes `c1`
- one contributes `c2`
- `c3` is set equal to `c2`

See around `glsl/Upscale/Anime4K_Upscale_CNN_x2_VL.glsl:960`.

So this variant effectively uses three distinct predicted components before residual add.

---

## 17) Residual add: why `+ MAIN_tex(MAIN_pos)`

Final return:

```glsl
return vec4(c0, c1, c2, c3) + MAIN_tex(MAIN_pos);
```

Interpretation:
- base = current input color
- network = detail delta
- output = base + delta

Why this is good:
- easier to learn small corrections
- keeps base structure stable
- reduces full-image hallucination risk

---

## 18) Compact pseudocode for whole file

```text
input = MAIN

// starter branches
a0 = Conv3x3(input)
b0 = Conv3x3(input)

// repeated dual-branch blocks (sign split inside)
(a1,b1) = Block(a0,b0)
(a2,b2) = Block(a1,b1)
(a3,b3) = Block(a2,b2)
(a4,b4) = Block(a3,b3)
(a5,b5) = Block(a4,b4)
(a6,b6) = Block(a5,b5)

// large 1x1 fusions
h0 = Fuse1x1(a0,b0,a1,b1,a2,b2,a3,b3,a4,b4,a5,b5,a6,b6)
h1 = Fuse1x1(a0,b0,a1,b1,a2,b2,a3,b3,a4,b4,a5,b5,a6,b6)
h2 = Fuse1x1(a0,b0,a1,b1,a2,b2,a3,b3,a4,b4,a5,b5,a6,b6)

// unpack to 2x space and add base
output = DepthToSpace2x(h0,h1,h2) + input
```

---

## 19) How to read this file efficiently

Recommended order:
1. Read only `//!DESC`, `//!BIND`, `//!SAVE` headers.
2. Draw pass graph (name -> name arrows).
3. Mark 3x3 blocks vs 1x1 blocks.
4. Mark sign split macros once (`go_*`, `g_*`).
5. Read depth-to-space pass last.
6. Ignore exact float constants until structure is clear.

This avoids drowning in constants.

---

## 20) Common confusion quick fixes

"Is 2x happening in every pass?"
- No. Most passes keep original size. Real spatial 2x mapping is final pass.

"Are 112 inputs equal to 112 bound textures?"
- No. 112 is logical channels after sign split.

"Does 1x1 conv do nothing useful?"
- No. It is powerful channel fusion at each pixel.

---

## 21) Why this file is a great master example

It includes almost all Anime4K CNN building blocks in one place:
- multi-pass pipeline
- 3x3 learned feature extraction
- sign split logic
- dual-branch refinement
- 1x1 fusion heads
- depth-to-space upscaling
- residual detail add
- conditional run via `//!WHEN`

Understand this file deeply, and many other Anime4K CNN shaders feel like smaller variants.

---

## 22) Useful anchors in source shader

- First pass header: `glsl/Upscale/Anime4K_Upscale_CNN_x2_VL.glsl:24`
- Second starter branch: `glsl/Upscale/Anime4K_Upscale_CNN_x2_VL.glsl:46`
- First dual-branch 16-input block: `glsl/Upscale/Anime4K_Upscale_CNN_x2_VL.glsl:68`
- First 1x1 fusion head: `glsl/Upscale/Anime4K_Upscale_CNN_x2_VL.glsl:704`
- Final depth-to-space header: `glsl/Upscale/Anime4K_Upscale_CNN_x2_VL.glsl:947`
- Final return line: `glsl/Upscale/Anime4K_Upscale_CNN_x2_VL.glsl:968`

---

If you want, next step can be a small "manual tracing worksheet" for one pixel (pass-by-pass), which is usually the fastest way to lock intuition.
